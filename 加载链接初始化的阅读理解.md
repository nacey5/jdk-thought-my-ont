## 运行时常量池

在开始阶段，每一个线程栈都包含一个独立的运行时常量池，所以常量等的调用的属性保存在这里

## 类加载器
一个行为良好的类加载器应该保持三个属性：

- 给定相同的名称，一个好的类加载器应该总是返回相同的Class对象。

- 如果类加载器 L1 将类 C 的加载委托给另一个加载器 L2，那么对于作为 C 的直接超类或直接超接口出现的任何类型 T，或作为 C 中字段的类型，或作为 C 中方法或构造函数的形式参数，或作为 C 中方法的返回类型，L1 和 L2 应返回相同的 Class 对象。

- 如果用户定义的类加载器预取类和接口的二进制表示，或者一起加载一组相关的类，那么它必须仅在程序中可能在没有预取或组加载的情况下出现的位置反映加载错误。

模块
未命名模块有特殊规则，旨在最大限度地提高它们与其他运行时模块的互操作性，如下所示：

- 类加载器的未命名模块不同于绑定到同一类加载器的所有其他运行时模块。

- 类加载器的未命名模块不同于绑定到其他类加载器的所有运行时模块（包括未命名模块）。

- 每个未命名的模块读取每个运行时模块。

- 每个未命名的模块都会向每个运行时模块导出与其自身关联的每个运行时包。

## 链接
链接类或接口涉及验证和准备该类或接口、它的直接超类、它的直接超接口和它的元素类型（如果它是数组类型），如果需要的话。链接还涉及解析类或接口中的符号引用，但不一定与验证和准备类或接口同时进行。

如果保持以下所有属性，则此规范允许在链接活动（以及由于递归、加载）发生时实现灵活性：

- 类或接口在链接之前已完全加载。

- 类或接口在初始化之前已经过完全验证和准备。

- 链接期间检测到的错误会在程序中的某个点抛出，在该点上，程序可能会直接或间接地采取某些操作，需要链接到错误中涉及的类或接口。

    直到 (i) 执行引用它的ldc、ldc_w或ldc2_w 指令，或 (ii) 调用将其作为静态参数引用的引导方法时， 才会解析对动态计算常量的符号引用。

- 直到调用将它作为静态参数引用的引导方法时，才会解析对动态计算的调用站点的符号引用。

例如，Java 虚拟机实现可能会选择一种“惰性”链接策略，其中类或接口中的每个符号引用（除了上面的符号引用）在使用时都被单独解析。或者，实现可以选择“急切”链接策略，其中在验证类或接口时立即解析所有符号引用。这意味着在某些实现中，在初始化类或接口之后，解析过程可能会继续。无论采用哪种策略，

因为链接涉及新数据结构的分配，它可能会失败并显示OutOfMemoryError.

## 验证
验证（ §4.10）确保类或接口的二进制表示在结构上是正确的（ §4.9）。验证可能会导致加载其他类和接口（ §5.3），但不需要对它们进行验证或准备。

如果类或接口的二进制表示不满足§4.9中列出的静态或结构约束，则VerifyError必须在程序中导致类或接口被验证的点处抛出 a。

如果 Java 虚拟机验证类或接口的尝试失败，因为抛出的错误是LinkageError类（或子类）的实例，则后续验证类或接口的尝试总是失败，并抛出与抛出的错误相同的错误初始验证尝试的结果。

## 准备
准备工作包括为类或接口创建静态字段并将这些字段初始化为其默认值（ §2.3、 §2.4）。这不需要执行任何 Java 虚拟机代码；静态字段的显式初始化器作为初始化（ §5.5）的一部分执行，而不是准备。

在准备类或接口C期间，Java 虚拟机还会施加加载约束（§5.3.4）：

让成为C的定义加载程序。对于 在C中声明的每个可以覆盖（第 5.4.5 节）在超类或超 接口D中声明的实例方法的实例方法，Java 虚拟机按如下方式施加加载约束。 L1m<L2>

假设的返回类型m是T r，并且形参类型m是T f1 , ..., T fn：

如果T r不是数组类型，则令T 0为T r；否则，令T 0为T r的元素类型。

对于i = 1 到n：如果T fi不是数组类型，则令T i为 T fi；否则，令T i为T fi的元素类型。

然后T i = T i对于i = 0 到n。 L1L2

对于在 C 的超接口 I 中声明的每个实例方法，m如果 <C本身不声明可以覆盖的实例方法，则选择一个方法（第 5.4.6 节）关于C和I中的方法。让D , L3>mm<L3><L2>是声明所选方法的类或接口。Java 虚拟机按如下方式施加加载约束。

假设的返回类型m是T r，并且形参类型m是T f1 , ..., T fn：

如果T r不是数组类型，则令T 0为T r；否则，令T 0为T r的元素类型。

对于i = 1 到n：如果T fi不是数组类型，则令T i为 T fi；否则，令T i为T fi的元素类型。

然后T i = T i对于i = 0 到n。 L2L3

准备工作可在创建后的任何时间进行，但必须在初始化之前完成。

## 解析
