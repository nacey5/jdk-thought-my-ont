## 运行时常量池

在开始阶段，每一个线程栈都包含一个独立的运行时常量池，所以常量等的调用的属性保存在这里

## 类加载器
一个行为良好的类加载器应该保持三个属性：

- 给定相同的名称，一个好的类加载器应该总是返回相同的Class对象。

- 如果类加载器 L1 将类 C 的加载委托给另一个加载器 L2，那么对于作为 C 的直接超类或直接超接口出现的任何类型 T，或作为 C 中字段的类型，或作为 C 中方法或构造函数的形式参数，或作为 C 中方法的返回类型，L1 和 L2 应返回相同的 Class 对象。

- 如果用户定义的类加载器预取类和接口的二进制表示，或者一起加载一组相关的类，那么它必须仅在程序中可能在没有预取或组加载的情况下出现的位置反映加载错误。

模块
未命名模块有特殊规则，旨在最大限度地提高它们与其他运行时模块的互操作性，如下所示：

- 类加载器的未命名模块不同于绑定到同一类加载器的所有其他运行时模块。

- 类加载器的未命名模块不同于绑定到其他类加载器的所有运行时模块（包括未命名模块）。

- 每个未命名的模块读取每个运行时模块。

- 每个未命名的模块都会向每个运行时模块导出与其自身关联的每个运行时包。

## 链接
链接类或接口涉及验证和准备该类或接口、它的直接超类、它的直接超接口和它的元素类型（如果它是数组类型），如果需要的话。链接还涉及解析类或接口中的符号引用，但不一定与验证和准备类或接口同时进行。

如果保持以下所有属性，则此规范允许在链接活动（以及由于递归、加载）发生时实现灵活性：

- 类或接口在链接之前已完全加载。

- 类或接口在初始化之前已经过完全验证和准备。

- 链接期间检测到的错误会在程序中的某个点抛出，在该点上，程序可能会直接或间接地采取某些操作，需要链接到错误中涉及的类或接口。

    直到 (i) 执行引用它的ldc、ldc_w或ldc2_w 指令，或 (ii) 调用将其作为静态参数引用的引导方法时， 才会解析对动态计算常量的符号引用。

- 直到调用将它作为静态参数引用的引导方法时，才会解析对动态计算的调用站点的符号引用。

例如，Java 虚拟机实现可能会选择一种“惰性”链接策略，其中类或接口中的每个符号引用（除了上面的符号引用）在使用时都被单独解析。或者，实现可以选择“急切”链接策略，其中在验证类或接口时立即解析所有符号引用。这意味着在某些实现中，在初始化类或接口之后，解析过程可能会继续。无论采用哪种策略，

因为链接涉及新数据结构的分配，它可能会失败并显示OutOfMemoryError.

## 验证
验证（ §4.10）确保类或接口的二进制表示在结构上是正确的（ §4.9）。验证可能会导致加载其他类和接口（ §5.3），但不需要对它们进行验证或准备。

如果类或接口的二进制表示不满足§4.9中列出的静态或结构约束，则VerifyError必须在程序中导致类或接口被验证的点处抛出 a。

如果 Java 虚拟机验证类或接口的尝试失败，因为抛出的错误是LinkageError类（或子类）的实例，则后续验证类或接口的尝试总是失败，并抛出与抛出的错误相同的错误初始验证尝试的结果。

## 准备
准备工作包括为类或接口创建静态字段并将这些字段初始化为其默认值（ §2.3、 §2.4）。这不需要执行任何 Java 虚拟机代码；静态字段的显式初始化器作为初始化（ §5.5）的一部分执行，而不是准备。

在准备类或接口C期间，Java 虚拟机还会施加加载约束（§5.3.4）：

让成为C的定义加载程序。对于 在C中声明的每个可以覆盖（第 5.4.5 节）在超类或超 接口D中声明的实例方法的实例方法，Java 虚拟机按如下方式施加加载约束。 L1m<L2>

假设的返回类型m是T r，并且形参类型m是T f1 , ..., T fn：

如果T r不是数组类型，则令T 0为T r；否则，令T 0为T r的元素类型。

对于i = 1 到n：如果T fi不是数组类型，则令T i为 T fi；否则，令T i为T fi的元素类型。

然后T i = T i对于i = 0 到n。 L1L2

对于在 C 的超接口 I 中声明的每个实例方法，m如果 <C本身不声明可以覆盖的实例方法，则选择一个方法（第 5.4.6 节）关于C和I中的方法。让D , L3>mm<L3><L2>是声明所选方法的类或接口。Java 虚拟机按如下方式施加加载约束。

假设的返回类型m是T r，并且形参类型m是T f1 , ..., T fn：

如果T r不是数组类型，则令T 0为T r；否则，令T 0为T r的元素类型。

对于i = 1 到n：如果T fi不是数组类型，则令T i为 T fi；否则，令T i为T fi的元素类型。

然后T i = T i对于i = 0 到n。 L2L3

准备工作可在创建后的任何时间进行，但必须在初始化之前完成。

## 解析
许多 Java 虚拟机指令 - anewarray、checkcast、getfield、 getstatic、instanceof、invokedynamic、invokeinterface、 invokespecial、invokestatic、invokevirtual、ldc、ldc_w、 ldc2_w、multianewarray、new、putfield和putstatic- 依赖运行时常量池中的符号引用。执行这些指令中的任何一个都需要解析符号引用。

解析是从运行时常量池中的符号引用动态确定一个或多个具体值的过程。最初，运行时常量池中的所有符号引用都未解析。

对 (i) 类或接口、(ii) 字段、(iii) 方法、(iv) 方法类型、(v) 方法句柄或 (vi) 动态计算常量的未解析符号引用的解析, 按照§5.4.3.1 至§5.4.3.5中给出的规则进行。在这些部分的前三个部分中，符号引用出现在其运行时常量池中的类或接口被标记为D。然后：

- 如果符号引用解析过程中没有出现错误，则解析成功。

    随后解决符号引用的尝试总是微不足道地成功，并导致与初始解决方案产生的相同实体。如果符号引用是动态计算的常量，则不会为这些后续尝试重新执行引导方法。

- 如果在解析符号引用期间发生错误，则它是 (i)的实例IncompatibleClassChangeError（或子类）；Error(ii)由引导方法的解析或调用产生的（或子类）实例；(iii)LinkageError由于类加载失败或违反加载程序约束而出现的（或子类）实例。必须在程序中（直接或间接）使用符号引用的某个点抛出错误。

后续解析符号引用的尝试总是失败，并出现与初始解析尝试相同的错误。如果符号引用是动态计算的常量，则不会为这些后续尝试重新执行引导方法。

因为在后续尝试中会再次抛出在初始尝试解析时发生的错误，所以一个模块中的类试图通过解析其运行时常量池中的符号引用来访问，public不同模块中的未导出类型将始终收到指示不可访问类型（§5.4.4）的相同错误，即使 Java SE 平台 API 用于public在类第一次尝试后的某个时间动态导出类型的包。

根据§5.4.3.6 中给出的规则，解析对动态计算的调用站点的未解析符号引用。然后：

- 如果在符号引用的解析过程中没有发生错误，则仅对class文件中需要解析的指令解析成功。该指令必须具有invokedynamic操作码。

    随后尝试 通过文件中的该指令class解析符号引用 总是很成功，并导致与初始解析产生的相同实体。对于这些后续尝试，不会重新执行引导方法。

    对于文件中任何操作码的所有其他指令，符号引用仍未解决，这些class操作码指示运行时常量池中与上述 invokedynamic指令相同的条目。

- 如果在解析符号引用期间发生错误，则它是 (i)的实例IncompatibleClassChangeError（或子类）；Error(ii)由引导方法的解析或调用产生的（或子类）实例；(iii)LinkageError由于类加载失败或违反加载程序约束而出现的（或子类）实例。必须在程序中（直接或间接）使用符号引用的某个点抛出错误。

    文件中同一指令 class解析符号引用的 后续尝试总是失败，并出现与初始解析尝试相同的错误。对于这些后续尝试，不会重新执行引导方法。

    对于文件中任何操作码的所有其他指令，符号引用仍未解决，这些class操作码指示运行时常量池中与上述 invokedynamic指令相同的条目。

在解析符号引用时，上面的某些指令需要额外的链接检查。例如，为了使 getfield指令成功解析对其操作的字段的符号引用，它不仅必须完成§5.4.3.2中给出的字段解析步骤，而且还要检查该字段是否不是static. 如果是static字段，则必须抛出链接异常。

由特定于特定 Java 虚拟机指令执行的检查生成的链接异常在该指令的描述中给出，并且不包含在解决方案的一般性讨论中。请注意，此类异常虽然被描述为 Java 虚拟机指令执行的一部分而不是解析，但仍被适当地视为解析失败。

### 类和接口的解析
要解析从D到由 表示的类或接口C 的未解析符号引用N，执行以下步骤：

1. D 的定义加载器用于加载并由此创建由 表示的类或接口N。这个类或接口是 C。该过程的详细信息在§5.3中给出。

    由于无法加载并因此创建C而可能引发的任何异常都可能 由于类和接口解析失败而被抛出。

2. 如果C是数组类并且其元素类型是类型，则通过递归调用§5.4.3.1reference中的算法来解析对表示元素类型的类或接口的符号引用。

3. 最后，访问控制应用于从D到C的访问 （§5.4.4）。

    如果第 1 步和第 2 步成功但第 3 步失败，则C仍然有效且可用。然而，解析失败，D被禁止访问C。

### 场分辨率
要解析从D到类或接口C中的字段 的未解析符号引用，必须首先解析由字段引用给出的对C的符号引用（ §5.4.3.1）。因此，任何可能因类或接口引用解析失败而抛出的异常都可能因字段解析失败而抛出。如果可以成功解析 对C的引用，则可以抛出与解析字段引用本身失败有关的异常。

解析字段引用时，字段解析首先尝试在C及其超类 中查找引用的字段：

1. 如果C使用字段引用指定的名称和描述符声明一个字段，则字段查找成功。声明的字段是字段查找的结果。

2. 否则，字段查找递归地应用于指定类或接口C的直接超接口。

3. 否则，如果C有一个超类S，则字段查找递归地应用于S。

4. 否则，字段查找失败。

然后，确定字段解析的结果：

- 如果字段查找失败，字段解析将抛出一个NoSuchFieldError.

- 否则，字段查找成功。访问控制适用于从D到作为字段查找结果的字段的访问（§5.4.4）。然后：

    - 如果访问控制失败，字段解析也会因为同样的原因而失败。

    - 否则访问控制成功。施加负载约束，如下所示。

        让<E成为实际声明引用字段的类或接口。让成为D的定义加载程序。鉴于引用字段的类型是T f：如果T f不是数组类型，则令 T为T f；否则，令T为T f的元素类型。 L1>L2

        Java 虚拟机施加了 T = T的加载约束。 L1L2

        如果施加此约束导致违反任何加载约束（§5.3.4），则字段解析失败。否则，字段解析成功。


## 初始化
    其实静态类的不用管，直接是使用jvm中的putStatic和getStatic或者invokeStatic，对于新定义的对象就是使用new开辟内存空间，当然需要对其和其父类进行校验
