# JDK19的学习文件

## 核心库/java.lang
### java.lang.ThreadGroup 已降级 (JDK-8284161)
旧版java.lang.ThreadGroup在此版本中已降级。不再可能显式销毁线程组。取而代之的ThreadGroup是，不再保留对子组的强引用。因此，当组中没有活动线程并且没有其他东西使线程组保持活动状态时，线程组就有资格进行 GC。

在先前版本中不推荐删除的几种方法的行为更改如下：

该destroy方法什么也不做。

该isDestroyed方法返回假。

setDaemonandisDaemon方法设置/获取不用于任何事情的守护进程状态。

suspend和方法抛出resume。stopUnsupportedOperationException

## 线程上下文类加载器更改为特殊的可继承线程本地 (JDK-8284161)
在此版本中，线程上下文ClassLoader被指定为特殊的可继承线程本地。Thread除了使用 5-arg构造函数（在 Java 9 中添加）来创建Thread不从构造线程继承可继承线程局部变量的初始值的代码之外，此更改对现有代码应该是透明的。在此版本中，调用 5-argThread构造函数并将参数inheritInheritableThreadLocals设置为false将创建一个Thread不ClassLoader从构造线程继承上下文初始值的构造函数。如果需要，该Thread.setContextClassLoader方法可用于更改ClassLoader新线程的上下文。
## JVM TI 更改以支持虚拟线程 (JDK-8284161)
JVM 工具接口 (JVM TI) 已在此版本中更新以支持虚拟线程。强烈建议使用 JVM TI 的代理维护者阅读JEP 425和 JVM TI 19.0 规范。以下是 JVM TI 对虚拟线程的支持总结：

大多数用 jthread 调用的 JVM TI 函数，例如对 Thread 对象的 JNI 引用，都可以用对虚拟线程的引用来调用。虚拟线程不支持的函数有PopFrame、ForceEarlyReturn、StopThread、AgentStartFunction和GetThreadCpuTime。这些SetLocal*函数支持在虚拟线程的最顶层帧中设置局部变量，这些虚拟线程在断点或单步事件处暂停，但JVMTI_ERROR_OPAQUE_FRAME在其他情况下允许失败。

所有 JVM TI 事件，除了那些在早期 VM 启动期间或堆迭代期间发布的事件之外，都可以在虚拟线程的上下文中调用事件回调。

和函数指定返回所有平台线程而不是所有线程GetAllThreads。GetAllStackTraces

添加了新功能SuspendAllVirtualThreads，ResumeAllVirtualThreads以支持虚拟线程的批量挂起和恢复。添加新事件VirtualThreadStart以VirtualThreadEnd支持跟踪虚拟线程。一种新功能，can_support_virtual_threads用于启用新功能和事件的使用。

现有的 JVM TI 代理大多会像以前一样工作，但如果它们调用虚拟线程不支持的函数，则可能会遇到错误。当不知道虚拟线程的代理与使用虚拟线程的应用程序一起使用时，就会出现这些问题。更改为GetAllThreads返回仅包含平台线程的数组可能是某些代理的问题。ThreadStart为所有线程启用和事件的现有代理ThreadEnd可能会遇到性能问题，直到它们被升级以更好地控制这些事件。


## JEP 425：虚拟线程的个人解读
原因： java内部定义的线程或者使用池化的线程无法满足持续上升的并发请求，
       因为java的线程满足了利特尔定律，所以其线程的处理量必须随着业务
       的增加而提高，遗憾的是java使用的技术无法满足，即使使用了池化的
       技术，但是jvm依然无法发挥出cpu该有的硬件实力，使用异步编程的风格
       又会导致开发人员的开发难度很大，且无法使用java硬编码。
       
解决方式：
        使用虚拟线程保留每个请求的线程样式
        为了使应用程序在与平台保持和谐的同时扩展，我们应该通过更有效地实现线程来努力保持线程每个请求的风格，这样它们就可以更丰富。操作系统无法更有效地实现操作系统线程，因为不同的语言和运行时以不同的方式使用线程堆栈。然而，Java 运行时可以通过一种将 Java 线程与 OS 线程一一对应的方式实现Java线程。就像操作系统通过将大的虚拟地址空间映射到有限的物理RAM来产生大量内存的错觉一样，Java运行时可以通过将大量虚拟线程映射到少量操作系统线程来产生大量线程的错觉.
        虚拟线程java.lang.Thread是不绑定到特定操作系统线程的实例。相比之下，平台线程是一个以传统方式实现的实例，java.lang.Thread作为围绕操作系统线程的薄包装器。
        thread-per-request风格的应用程序代码可以在整个请求期间在虚拟线程中运行，但虚拟线程仅在CPU上执行计算时才消耗OS线程。结果是与异步样式相同的可伸缩性，除了它是透明地实现的：当运行在虚拟线程中的代码调用阻塞 I/O操作时java.*API，运行时执行非阻塞操作系统调用并自动挂起虚拟线程，直到稍后可以恢复。对于Java开发人员来说，虚拟线程只是创建成本低且几乎无限多的线程。硬件利用率接近最佳，允许高水平的并发性，从而实现高吞吐量，同时应用程序与Java平台及其工具的多线程设计保持一致。
也就是说，虚拟线程类似于os，将大量的虚拟地址映射到到实际的线程中，但是是以一种`1--->n`的的方式，造成可以创建无限多线程的假象。

### 官方描述：
java.lang.Thread今天， JDK 中的每个实例都是一个平台线程。平台线程在底层操作系统线程上运行 Java 代码，并在代码的整个生命周期内捕获操作系统线程。平台线程数受限于 OS 线程数。
虚拟线程java.lang.Thread是在底层 OS 线程上运行 Java 代码但在代码的整个生命周期内不捕获 OS 线程的实例。这意味着许多虚拟线程可以在同一个操作系统线程上运行它们的 Java 代码，从而有效地共享它。虽然平台线程独占宝贵的操作系统线程，但虚拟线程却没有。虚拟线程的数量可以远大于操作系统线程的数量。
虚拟线程是由 JDK 而不是 OS 提供的线程的轻量级实现。它们是用户模式线程的一种形式，在其他多线程语言中已经成功（例如，Go 中的 goroutine 和 Erlang 中的进程）。用户模式线程甚至在 Java 的早期版本中被称为“绿色线程”，当时操作系统线程还没有成熟和普及。然而，Java 的绿色线程都共享一个 OS 线程（M:1 调度）并最终被平台线程超越，实现为 OS 线程的包装器（1:1 调度）。虚拟线程采用 M:N 调度，其中大量 (M) 虚拟线程被调度为在较少数量 (N) 的 OS 线程上运行。

也即是说  `jdk.version<19  jdk.thread-->os.thread==1:1`,当`jdk.version==19 jdk.thread-->os.thread==m:n`,且`m<<n（m远小于n）`

### 用法
开发者可以选择是使用虚拟线程还是平台线程。这是一个创建大量虚拟线程的示例程序。程序首先获得一个ExecutorService，它将为每个提交的任务创建一个新的虚拟线程。然后它提交 10,000 个任务并等待所有任务完成：
~~~java
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 10_000).forEach(i -> {
        executor.submit(() -> {
            Thread.sleep(Duration.ofSeconds(1));
            return i;
        });
    });
}  // executor.close() is called implicitly, and waits
~~~
个例子中的任务是简单的代码——休眠一秒钟——现代硬件可以很容易地支持 10,000 个虚拟线程同时运行这样的代码。在幕后，JDK 在少数操作系统线程上运行代码，可能只有一个。

如果该程序使用ExecutorService为每个任务创建新平台线程的Executors.newCachedThreadPool(). 这ExecutorService将尝试创建 10,000 个平台线程，从而创建 10,000 个 OS 线程，并且程序可能会崩溃，具体取决于机器和操作系统。

相反，如果程序使用ExecutorService从池中获取平台线程的Executors.newFixedThreadPool(200). 这ExecutorService将创建 200 个平台线程供所有 10,000 个任务共享，因此许多任务将按顺序运行而不是同时运行，并且程序需要很长时间才能完成。对于这个程序，具有 200 个平台线程的池只能实现每秒 200 个任务的吞吐量，而虚拟线程可以实现大约每秒 10,000 个任务的吞吐量（在充分预热之后）。此外，如果将10_000示例程序中的 更改为1_000_000，则该程序将提交 1,000,000 个任务，创建 1,000,000 个并发运行的虚拟线程，并且（在充分预热后）达到每秒约 1,000,000 个任务的吞吐量。

所以，虚拟线程的存在并不是其比平台线程的运行速度快，而是其能够存在大量的虚拟线程请求，从而提高吞吐量。


### 虚拟线程是一个预览 API，默认禁用
上述程序使用该Executors.newVirtualThreadPerTaskExecutor()方法，因此要在 JDK 19 上运行它们，您必须启用预览 API，如下所示：

用 编译程序并用;javac --release 19 --enable-preview Main.java运行它 java --enable-preview Main或者，

使用源代码启动器java --source 19 --enable-preview Main.java时，使用;运行程序 或者，

使用jshell时，请以jshell --enable-preview.

## 使用虚拟线程的注意点
### 不要池化虚拟线程
开发人员通常会将应用程序代码从基于线程池ExecutorService的传统迁移到每个任务的虚拟线程。ExecutorService线程池与所有资源池一样，旨在共享昂贵的资源，但虚拟线程并不昂贵，并且永远不需要池化它们。

开发人员有时会使用线程池来限制对有限资源的并发访问。例如，如果一个服务不能处理超过 20 个并发请求，那么通过提交到大小为 20 的池的任务执行对服务的所有访问将确保这一点。由于平台线程的高成本使得线程池无处不在，这个习语也变得无处不在，但开发人员不应该为了限制并发而试图将虚拟线程池化。为此目的而专门设计的结构，例如信号量，应该用于保护对有限资源的访问。这比线程池更有效、更方便，也更安全，因为不存在线程本地数据意外从一个任务泄漏到另一个任务的风险。

### 监控
编写清晰的代码并不是全部。对正在运行的程序状态的清晰表示对于故障排除、维护和优化也很重要，JDK 长期以来一直提供调试、分析和监视线程的机制。这样的工具应该对虚拟线程做同样的事情——也许对它们的大量进行一些调整——因为它们毕竟是java.lang.Thread.

Java 调试器可以单步执行虚拟线程、显示调用堆栈以及检查堆栈帧中的变量。JDK Flight Recorder (JFR) 是 JDK 的低开销分析和监控机制，可以将来自应用程序代码的事件（例如对象分配和 I/O 操作）与正确的虚拟线程相关联。这些工具不能为以异步方式编写的应用程序做这些事情。在这种风格中，任务与线程无关，因此调试器无法显示或操作任务的状态，并且分析器无法判断任务等待 I/O 所花费的时间。

线程转储是另一种流行的工具，用于对以每个请求线程编写的应用程序进行故障排除。jstack不幸的是，使用or获得的 JDK 的传统线程转储jcmd提供了一个平面的线程列表。这适用于数十或数百个平台线程，但不适用于数千或数百万个虚拟线程。因此，我们不会将传统的线程转储扩展到包括虚拟线程，而是引入一种新的线程转储，jcmd以将虚拟线程与平台线程一起呈现，所有这些都以有意义的方式分组。当程序使用结构化并发时，可以显示线程之间更丰富的关系。

因为可视化和分析大量线程可以从工具中受益，jcmd所以除了纯文本之外，还可以以 JSON 格式发出新的线程转储：
~~~shell
$ jcmd <pid> Thread.dump_to_file -format=json <file>
~~~
新的线程转储格式列出了在网络 I/O 操作中被阻塞的虚拟线程，以及由ExecutorService上面显示的 new-thread-per-task 创建的虚拟线程。它不包括对象地址、锁、JNI 统计信息、堆统计信息以及出现在传统线程转储中的其他信息。此外，由于它可能需要列出大量线程，因此生成新的线程转储不会暂停应用程序。

下面是oracle提供的一张图：
![image.png](https://note.youdao.com/yws/res/1847/WEBRESOURCEd5eaae617d3554024d69d5e370d03cb6)
由于虚拟线程是在 JDK 中实现的，并且不依赖于任何特定的操作系统线程，因此它们对操作系统是不可见的，操作系统不知道它们的存在。操作系统级别的监控将观察到 JDK 进程使用的操作系统线程少于虚拟线程。

### 调度虚拟线程
为了做有用的工作，线程需要被调度，也就是说，被分配在处理器内核上执行。对于作为 OS 线程实现的平台线程，JDK 依赖于 OS 中的调度程序。相比之下，对于虚拟线程，JDK 有自己的调度程序。JDK 的调度程序不是直接将虚拟线程分配给处理器，而是将虚拟线程分配给平台线程（这就是前面提到的虚拟线程的 M:N 调度）。平台线程然后像往常一样由操作系统调度。

JDK 的虚拟线程调度程序是一种工作窃取ForkJoinPool，以 FIFO 模式运行。调度程序的并行度是可用于调度虚拟线程的平台线程数。默认情况下，它等于可用处理器的数量，但可以使用系统属性进行调整jdk.virtualThreadScheduler.parallelism。请注意，这与在并行流的实现中使用的公共池ForkJoinPool不同，它在 LIFO 模式下运行。

调度程序分配虚拟线程的平台线程称为虚拟线程的载体。虚拟线程可以在其生命周期内调度到不同的载体上；换句话说，调度程序不维护虚拟线程和任何特定平台线程之间的关联。从 Java 代码的角度来看，一个正在运行的虚拟线程在逻辑上是独立于它当前的载体的：

- 虚拟线程无法获得载体的身份。返回的值Thread.currentThread()始终是虚拟线程本身。

- 载体和虚拟线程的堆栈跟踪是分开的。虚拟线程中抛出的异常将不包括载体的堆栈帧。线程转储不会在虚拟线程的堆栈中显示载体的堆栈帧，反之亦然。

- 载体的线程局部变量对虚拟线程不可用，反之亦然。

另外，从Java代码的角度来看，虚拟线程和它的载体暂时共享一个OS线程是不可见的。相比之下，从本机代码的角度来看，虚拟线程及其载体都运行在同一个本机线程上。因此，在同一虚拟线程上多次调用的本机代码可能会在每次调用时观察到不同的 OS 线程标识符。

调度程序当前没有为虚拟线程实现时间共享。时间共享是强制抢占已消耗分配数量的 CPU 时间的线程。当平台线程数量相对较少且 CPU 利用率为 100% 时，分时可以有效减少某些任务的延迟，但不清楚分时是否会与一百万个虚拟线程一样有效。
### 执行虚拟线程

要利用虚拟线程，无需重写程序。虚拟线程不需要或期望应用程序代码明确地将控制权交还给调度程序；换句话说，虚拟线程是不合作的。用户代码不得对虚拟线程如何或何时分配给平台线程做出假设，就像它对平台线程如何或何时分配给处理器内核做出假设一样。

为了在虚拟线程中运行代码，JDK 的虚拟线程调度程序通过将虚拟线程安装在平台线程上来分配虚拟线程以在平台线程上执行。这使得平台线程成为虚拟线程的载体。稍后，在运行一些代码之后，虚拟线程可以从它的载体上卸载。此时平台线程是空闲的，因此调度程序可以在其上安装不同的虚拟线程，从而使其再次成为载体。

通常，当虚拟线程阻塞 I/O 或 JDK 中的某些其他阻塞操作时，虚拟线程将卸载，例如BlockingQueue.take(). 当阻塞操作准备好完成时（例如，已经在套接字上接收到字节），它会将虚拟线程提交回调度程序，调度程序会将虚拟线程安装在载体上以恢复执行。

虚拟线程的挂载和卸载频繁且透明，不会阻塞任何操作系统线程。例如，前面显示的服务器应用程序包括以下代码行，其中包含对阻塞操作的调用：

response.send(future1.get() + future2.get());
这些操作将导致虚拟线程多次挂载和卸载，通常每次调用一次，get()并且可能在执行 I/O 过程中多次send(...)。

JDK 中的绝大多数阻塞操作将卸载虚拟线程，释放其载体和底层操作系统线程以承担新的工作。但是，JDK 中的一些阻塞操作不会卸载虚拟线程，因此会阻塞其载体和底层操作系统线程。这是因为在操作系统级别（例如，许多文件系统操作）或在 JDK 级别（例如，Object.wait()）的限制。这些阻塞操作的实现将通过临时扩展调度程序的并行性来补偿对 OS 线程的捕获。因此，调度程序中的平台线程数量ForkJoinPool可能会暂时超过可用处理器的数量。调度程序可用的最大平台线程数可以通过系统属性进行调整jdk.virtualThreadScheduler.maxPoolSize。

有两种情况下，在阻塞操作期间无法卸载虚拟线程，因为它被固定在其载体上：

synchronized当它在块或方法内执行代码时，或当它执行一个native方法或一个外部函数时。
固定不会使应用程序不正确，但可能会阻碍其可伸缩性。如果虚拟线程执行诸如 I/O 之类的阻塞操作或BlockingQueue.take()在它被固定时，那么它的载体和底层操作系统线程在操作期间被阻塞。长时间频繁固定可能会通过捕获载体来损害应用程序的可扩展性。

调度程序不会通过扩展其并行性来补偿固定。相反，通过修改频繁运行的块或方法来避免频繁和长期的钉住，synchronized并保护潜在的长 I/O 操作以java.util.concurrent.locks.ReentrantLock代替使用。不需要替换synchronized不经常使用（例如，仅在启动时执行）或保护内存中操作的块和方法。与往常一样，努力保持锁定策略简单明了。

新的诊断有助于将代码迁移到虚拟线程并评估是否应该用锁替换特定synchronized用途java.util.concurrent：

- 当线程在固定时阻塞时会发出 JDK Flight Recorder (JFR) 事件（请参阅JDK Flight Recorder）。

- 当线程在固定时阻塞时，系统属性jdk.tracePinnedThreads会触发堆栈跟踪。当线程在固定时阻塞时，运行 with-Djdk.tracePinnedThreads=full会打印完整的堆栈跟踪，并突出显示本机帧和保持监视器的帧。运行时-Djdk.tracePinnedThreads=short将输出限制为有问题的帧。

在未来的版本中，我们可能会移除上面的第一个限制（固定在里面synchronized）。第二个限制是与本机代码正确交互所必需的。

-------------------
也就是说，内部使用synchronized代码块可能导致长期的代码钉死，导致jvm的gc难度大，会导致其内存分裂，也就是出现内存裂缝，导致其碎片化内存无法整理和分区过多。

### 内存使用和与垃圾收集的交互
内存使用和与垃圾收集的交互
虚拟线程堆栈作为堆栈块对象存储在 Java 的垃圾收集堆中。堆栈随着应用程序的运行而增长和缩小，既是为了节省内存，又是为了适应任意深度的堆栈（直到 JVM 配置的平台线程堆栈大小）。这种效率使大量虚拟线程成为可能，从而使服务器应用程序中的每请求线程样式持续存在。

在上面的第二个例子中，假设一个框架通过创建一个新的虚拟线程并调用该handle方法来处理每个请求；即使它handle在深度调用堆栈的末尾调用（在身份验证、事务等之后），handle它本身也会产生多个只执行短期任务的虚拟线程。因此，对于每个调用堆栈较深的虚拟线程，都会有多个调用堆栈较浅的虚拟线程占用很少的内存。

一般来说，虚拟线程所需的堆空间和垃圾收集器活动量很难与异步代码相比。一百万个虚拟线程至少需要一百万个对象，但共享一个平台线程池的一百万个任务也是如此。此外，处理请求的应用程序代码通常会跨 I/O 操作维护数据。每个请求的线程代码可以将该数据保存在局部变量中，这些变量存储在堆中的虚拟线程堆栈中，而异步代码必须将相同的数据保存在从管道的一个阶段传递到下一个阶段的堆对象中。一方面，虚拟线程所需的栈帧布局比紧凑对象更浪费；另一方面，虚拟线程可以在许多情况下改变和重用它们的堆栈（取决于低级 GC 交互），而异步管道总是需要分配新对象，因此虚拟线程可能需要更少的分配。总体而言，每个请求线程与异步代码的堆消耗和垃圾收集器活动应该大致相似。随着时间的推移，我们希望使虚拟线程堆栈的内部表示更加紧凑。

与平台线程堆栈不同，虚拟线程堆栈不是 GC 根，因此执行并发堆扫描的垃圾收集器（例如 G1）不会在停止世界的暂停中遍历其中包含的引用。这也意味着如果一个虚拟线程被阻塞，例如，BlockingQueue.take()并且没有其他线程可以获取对虚拟线程或队列的引用，那么该线程可以被垃圾回收——这很好，因为虚拟线程永远不能被打断或畅通。当然，如果虚拟线程正在运行或者它被阻塞并且可能被解除阻塞，它就不会被垃圾回收。

虚拟线程的当前限制是 G1 GC 不支持巨大的堆栈块对象。如果虚拟线程的堆栈达到区域大小的一半，可能小至 512KB，则StackOverflowError可能会抛出 a。

----
具体的参照JEP-425
