# 外部api的孵化
省略，对于外部navice方法的调用，现阶段并没有过多的接触，但是根据其JEP424
的描述来讲，目前oracle正在致力研究一种可以边界调用跨界的api，使得jvm可以更好的适用外部函数，而不是使用jit去调用unsafe方法，jit对于所有内存都是可见的，调用unsafe方法可能会出现很多危险的情况，oom甚至非常常见。
# 结构化并发 JEP428
 介绍：
 通过引入用于结构化并发的 API 来简化多线程编程。结构化并发将在不同线程中运行的多个任务视为单个工作单元，从而简化错误处理和取消，提高可靠性并增强可观察性。
 
 非目标：
 定义在线程之间共享数据流（即通道）的方法不是目标。我们可能会建议将来这样做。

用新的线程取消机制替换现有的线程中断机制不是目标。我们可能会建议将来这样做。

【突然想起了gmp和csp模型，个人感觉未来java会有这个，我们可以期待下
jdk20，20应该是一个大版本】

## 描述
结构化并发
结构化并发是一种多线程编程方法，它保留了单线程代码的可读性、可维护性和可观察性。它体现了这样的原则

如果一个任务拆分成并发的子任务，那么它们都会返回同一个地方，即任务的代码块。

“结构化并发”一词由Martin Sústrik创造，并由Nathaniel J. Smith推广。来自其他语言的想法，例如 Erlang 的分层监督程序，为结构化并发中的错误处理设计提供了信息。

在结构化并发中，子任务代表任务工作。该任务等待子任务的结果并监视它们是否失败。与单线程代码的结构化编程技术一样，多线程结构化并发的强大功能来自两个想法：(1) 通过代码块的执行流定义明确的入口点和出口点，以及 (2)严格嵌套操作的生命周期，以反映它们在代码中的语法嵌套的方式。

因为代码块的入口点和出口点是明确定义的，并发子任务的生命周期被限制在其父任务的句法块中。因为兄弟子任务的生命周期嵌套在它们父任务的生命周期中，所以它们可以作为一个单元进行推理和管理。因为父任务的生命周期又嵌套在其父任务的生命周期中，所以运行时可以将任务的层次结构具体化为一棵树。该树是单个线程调用堆栈的并发对应物，可观察性工具可以使用它来呈现子任务从属于它们的父任务。

结构化并发非常适合虚拟线程，虚拟线程是由 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，允许大量的虚拟线程。除了数量丰富之外，虚拟线程的成本也足够低，可以表示任何并发的行为单元，甚至是涉及 I/O 的行为。这意味着服务器应用程序可以使用结构化并发来同时处理数千或数百万个传入请求：它可以将一个新的虚拟线程专用于处理每个请求的任务，并且当一个任务通过提交并发执行的子任务来散开时，它可以为每个子任务分配一个新的虚拟线程。在幕后，

总之，虚拟线程提供了丰富的线程。结构化并发确保它们得到正确和稳健的协调，并使可观察性工具能够按照开发人员理解的方式显示线程。在 JDK 中拥有用于结构化并发的 API 将提高服务器应用程序的可维护性、可靠性和可观察性。

【我自己总感觉结构化并发就是为了配合虚拟线程而生存的，我之前看过一个段子，就是go语言很像一把没有装外壳的枪，虽然能连发，但是每次总是得问，好了没，好了我就继续连发了，然后连着连着就云里雾里了。虚拟线程与结构化并发的配合能够使得每一个子任务更像一个具体的线程，但是又不会占用更大的线程开销，这种设计思路叹为观止】
### 使用流程
使用StructuredTaskScope
代码使用的大致流程StructuredTaskScope如下：

创建范围。创建作用域的线程是它的所有者。

在范围内分叉并发子任务。

作用域中的任何分支或作用域的所有者都可以调用作用域的shutdown()方法来请求取消所有剩余的子任务。

作用域的所有者作为一个单元加入作用域，即它的所有分支。所有者可以调用范围的join()方法，该方法会阻塞，直到所有分叉完成（成功或不成功）或通过取消shutdown()。或者，所有者可以调用范围的joinUntil(java.time.Instant)方法，该方法接受截止日期。

加入后，处理分叉中的任何错误并处理其结果。

关闭范围，通常通过try-with-resources 隐式地关闭。这将关闭范围并等待任何零散的分叉完成。
【真的好像go里面的channle，虽然在上面的非目标中已经明确说明了这个东西不是channel】

目前官方给出的报告是继续使用低级的concurrentAPi，不过我们可以期待后续的发展
