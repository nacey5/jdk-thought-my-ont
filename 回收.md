# 事务内存

事务内存必须提供以下几种操作：原子化写操作，冲入检测，可见性控制(以支持隔离性)
可见性控制可以作为冲突检测的一部分
![image.png](https://note.youdao.com/yws/res/2015/WEBRESOURCE3d59600a97dcd913874ce0b045cabcc8)

# 垃圾回收

包括 stw回收,增量回收，并发回收
![image.png](https://note.youdao.com/yws/res/2133/WEBRESOURCE5f3c426296a9e863281956a79761d9a7)

# 负载均衡的设计主要针对的阶段

![image.png](https://note.youdao.com/yws/res/2138/WEBRESOURCE37931a93ea6cdc251675c449bda93346)
主要是针对这三个阶段进行负载均衡的设计

## 复制回收器的注意点

在进行对象的复制转发的时候一般来讲不能多次操作同个对象，否贼会引起内存空间的拓扑结构发生变化导致内存空间的连续访问出现问题，一般的解决是引入繁忙位和原子操作语句\[充当内存屏障]，使用少量的消耗换来语句和空间的有序是非常值得的。
![image.png](https://note.youdao.com/yws/res/2601/WEBRESOURCEb17db65c8173eb2ac70f6b4cc02e7176)

## 三色不变式

### 强三色不变式

    要求黑色根只能引用灰色或者黑色对象

### 弱三色不变式

    允许黑色根指向白色对象，但是白色对象必须处于灰色保护状态。

灰色保护状态的出现是为了防止出现悬挂指针以及对象丢失问题
`两个不变式相辅相成` ---弱三色扫描中，在扫描波面之后去引用可能会导致出现对象丢失，所以需要引入灰色保护

## 卡表

使用脏卡和卡页来对页面进行挂载---好处，大部分垃圾是连在一起的，使用记忆集通常通常能够大幅度的提高回收效率，坏处是可能脏卡在被回收之后可能被重新打上一个脏标记，导致需要再次扫描。

### 单级卡表

![image.png](https://note.youdao.com/yws/res/2623/WEBRESOURCEbc95719a39f86dadeb77010126611609)

### 两级卡表

![image.png](https://note.youdao.com/yws/res/2626/WEBRESOURCEd38c701d782e9f7806446079498705be)

## 重复扫描解决方法

### 扫描仅标记，回收再追踪

![image.png](https://note.youdao.com/yws/res/2637/WEBRESOURCE9ea49d7419021d596db483e0eb57c5bf)

### 降低脏卡的数量

![image.png](https://note.youdao.com/yws/res/2641/WEBRESOURCEc1588e89251709b529a325bd29d54c87)
![image.png](https://note.youdao.com/yws/res/2643/WEBRESOURCEc469402cd62dbb709c8b3defd5585ef4)

## 混合分代/并发回收器的优势

![image.png](https://note.youdao.com/yws/res/2652/WEBRESOURCE5844cd0f01df16e7626b52049dc63dda)

## 对于实时系统--实时回收等
重要也需要解决的点就是减少回收器对赋值器的中断，采用的可以是原子化的推荐回收的灰色波面，采用读屏障
![image.png](https://note.youdao.com/yws/res/2666/WEBRESOURCEade746a63fd1f88ef2f52d33f7c69d7b)

# 并发复制/并发整理
## Baker回收器的Broker间接屏障
这种屏障手段，借助于间接引用的方式放宽了目标空间的不变式要求，但是依然有访问到灰色波面之前的对象的风险
### 自删除读屏障
使用一个代码入口，入口指针将不将会进行对象的复制。当回收器启动之后，某个对象被复制到目标空间中，回收器会将新副本的入口指针修改为自我复制能力的求值代码。具体所示：
![image.png](https://note.youdao.com/yws/res/2709/WEBRESOURCE0aa7898f9690766be14c44e7c15cc467)
![image.png](https://note.youdao.com/yws/res/2711/WEBRESOURCE518cb70ccfa2462a099079bb6d55b587)

# 完全并发，完全并行的回收器-PauseLess回收器
![image.png](https://note.youdao.com/yws/res/2713/WEBRESOURCEf240ead3c600574f7d220c2a29fe1a3b)
具体情况可以查找资料或者看书




## 有以下几个点需要更好的清楚：
- 屏障：屏障是什么？内存屏障的优以及劣？屏障的实现方式以及屏障的选择
- 回收器：回收器的种类以及在各种方案中如何选择
- 算法： 各种各样的算法如何适应
- 三色标记的代表以及他们的转换，以及他们可能出现的异常在哪里


我可以简单的描述上述的解决方案，但是更加具体的情况需要各位自己更加仔细去看书或者论文进行了解。
屏障这个名词出现，其实就是为了解决在编译器/cpu等由于对指令的优化导致的出现指令重排的问题，导致了在**多线程**的情况下可能会导致出现一些脏读以及高速缓存无法命中`(每个cpu线程都会有自己的缓存)`,包括读的问题，写的问题，所以我们经常会听到一些名词可能是针对事务的，成为脏读，脏写，脏数据以及高速缓存无法命中`（当然具体情况更加复杂）`,但是在其中有必要指出的是，缓存的同步顺序可能会导致指令的重排，这也是因为每个cpu拥有自己的缓存空间导致的，这也是后来系统会设计一个`MESI`协议。这个协议我也简单的从网上放出简介，也不自己敲了：
- 处于“Modified”状态的缓存行：当前CPU已经对缓存行的数据进行了修改，但是该缓存行的内容并没有在其它CPU的缓存中出现。因此，处于该状态的缓存行可以认为被当前CPU所“拥有”。这就是所谓的“脏”行，它的内容和内存中的内容不一样。由于只有当前CPU的缓存持有最新的数据，因此要么将“脏”数据写回到内存，要么将该数据“转移”给其它缓存。
- 处于“Exclusive”状态的缓存行：该状态非常类似于“Modified”状态，缓存的内容确保没有在其它CPU的缓存中出现。唯一的差别是，该缓存行还没有被当前的CPU修改，也就是说缓存行内容和内存中的是一样，是对内存数据的最新复制。但是，由于当前CPU能够在任何时刻将数据存储到该缓存行而不考虑其它CPU，因此处于“Exclusive”状态的缓存行也可以认为被当前CPU所“拥有”。
- 处于“Shared”状态的缓存行：表示缓存行的数据和主存中的一样，并且可能已经被复制到至少一个其它CPU的缓存中。但是，在没有得到其他CPU“许可”的情况下，任何CPU不能向该缓存行存储数据。与“Exclusive”状态相同，由于内存中的值是最新的，因此当需要丢弃该缓存行时，可以不用向内存回写。
- 处于“Invalid”状态的缓存行：表示该缓存行已经失效了，不能再被继续使用了。当有新数据进入缓存时，它可以直接放置到一个处于“Invalid”状态的缓存行上，不需要做其它的任何处理。

所以就会出现在很多接触底层的小伙伴可能会听到这个名词，叫顺序流入，乱序流出，这跟cpu中的架构设计有着很大的关系。`现代系统会更加的为性能考虑，几乎所有系统已经没用采取实时同步了，都是采用最终同步的策略`

切回正题：屏障到底是什么，网上也有很多资料，但是在我理解的就像一道隔膜一样，位于屏障之前的特定操作，如果屏障之后的操作发生了，屏障之前的特定操作就一定在此操作之前发生。可能这么说有一点抽象，我用一个比喻`(紧跟时事):`就如果一个核酸队伍，每过10个人需要有核酸队长拿一个核酸管，后面跟着9个人，这10个人就是一个队伍，然后现在有3个队伍：A，B，C，也就是30个人，也就是3个队伍`这三个队长就是屏障`，核酸队伍要求的就是你们三个队伍要按照一定的顺序排序，可以为`ABC`,`ACB`,`BAC`,`BCA`,`CAB`,`CBA`,以上的情况都可以发生，但是你不知道是以上的哪一种，但是可以肯定的是，无论是哪一种顺序，其一整个小队的顺序是确定下来了的:
我以一个来作为例子，比如可能出现的情况为 `CAB`:
那么`C队伍最先做，其次是A，最后是B`:也就是说C队伍是最先做的，所以C的10个人就比A队伍和B队伍先做完核酸，但是其队内的顺序可能发生变化：我给出一个例子:`C小队`：对内的核酸顺序可能为
`C1,C3,C4,C2,C5,C6,C9,C7,C8,C10`，
`C1,C2,C3,C4....`[省略了]，
如此看来，B做完了，那么A一定做完了，A做完了，C肯定做完了，但是每个队内的顺序是不一定的，每个队伍的队长就是屏障。
我想我应该描述的比较清楚了，屏障分为很多种：编译屏障，写屏障，读屏障，内存屏障[读，写屏障]

回收器：回收器这个方面涉及的更多，主要是针对于业务量具体进行请求，所以需要更加专业的研判手段以及选择策略，具体参考一些回收器的书籍[例如某些回收器可能只是在进行环形对象链的回收有一些差别，有的采用的是锁，有的采用的是atmoi原语]

算法：算法也是如此，有的算法可能需要在效率，准确性以及吞吐量进行一个三角衡量

三色标记的代表:强三色以及弱三色的区别，赋值器和回收器需要进行的适配是什么，这些点都较为的有深度以及更新策略
